## Other SQL Queries

### INSERT

Adds one or more tuples to a relation. The following requires all attributes to be listed in the same order they were specified when the table was created:

```sql
INSERT INTO table_name VALUES (attr_1, ..., attr_n)
```

To specify the attributes to insert:

```sql
INSERT INTO table_name (attr_name_1, ..., attr_name_n) VALUES (attr_1, ..., attr_n)
```

Both forms allow you to insert multiple tuples, separating them with commas.

A select statement can be used to insert multiple tuples:

```sql
INSERT INTO table_name (attr_name_list) select_statement
```

NB: two single quotes escape a quote in a string literal.

### UPDATE

```sql
UPDATE table_name SET attr_name_1 = expression_1, ... WHERE where_condition
```

The where condition is optional.

### DELETE

```sql
DELETE FROM table_name WHERE where_condition
```

You can only delete data from one table at a time (except if `CASCADE` is used on a foreign key)

If the where condition is missing, every row gets deleted.

### Views

Views are virtual tables - essentially a stored query that allows customized access to data (e.g. remove access to some sensitive attributes of a table).

In general, for a view to be updatable (varies by implementation):

- Must be defined over a single table
- Must contain a primary or candidate key of the base relation
- Cannot use grouping or aggregate functions

```sql
CREATE VIEW view_name AS select_statement
```

Once a view is created, it can be queried like a normal table.

To drop a view

```sql
DROP VIEW view_name
```

In Oracle, to find out which views are updatable:

```sql
SELECT column_name, updatable FROM user_updatable_columns WHERE table_name=upper('view_name')
```

### Indexes

Indexes are a physical-level feature; access structures to speed up queries.

```sql
CREATE INDEX index_name ON table_name (attr_name_1, ...)
```

In older versions of Oracle, indexes would not be created for keys. In this case, a index would need to be created with the `UNIQUE` keyword.

`DROP INDEX index_name` is used to delete indexes.

Notes:

- Indexes should be created **before tables are populated**
- Indexes should not be created for attributes that are frequently updated
- Current versions of Oracle creates indexes for primary and secondary keys
- Indexes are often used in search and join conditions

### Integrity Component

SQL 92 adds:

- Required data (`NOT NULL)`
- Domain constraints
- Entity integrity (`PRIMARY KEY`, `UNIQUE`)
- Referential integrity (`FOREIGN KEY`, `REFERENCES`)
- Referential integrity constraint violation behaviour (`ON UPDATE`, `ON DELETE`)
- Enterprise constraints

#### Domain Constraints

Not in Oracle:

```sql
CREATE DOMAIN domain_name AS data_type DEFAULT default_option CHECK (search_option)
```

Both `DEFAULT` and `CHECK` are optionals, and `search_option` should reference the value of the value using `VALUE`.

Use `DROP DOMAIN domain_name`, optionally appending `RESTRICT` or `CASCADE`.

#### Referential Integrity Violation

The qualifiers are `ON DELETE` and `ON UPDATE`

The options are `SET NULL`, `CASCADE` and `SET DEFAULT`

Oracle only supports `ON DELETE CASCADE` and `ON DELETE SET NULL`

#### Enterprise Constraints

##### Constraints

```sql
CONSTRAINT constraint_name CHECK (condition)
```

This is for a specific table, so the condition can reference multiple attributes. In SQL2, the condition may include a nested `SELECT` statement.

##### Assertions

Constraints spanning multiple tables can be made: these are called assertions.

```sql
CREATE ASSERTION assertion_name CHECK (search_condition)
```

The search condition will be a SQL query, probably using the `EXISTS` keyword.

This is not supported in Oracle.

##### Triggers

Triggers monitors the state of the database and performs some action when a specific condition occurs.

Triggers can:

- Calculate/update values of derived attributes
- Enforce additional constraints
- Prevent invalid transactions
- Automatically perform actions
- Audit changes
- Maintain replicated tables 

A trigger has an **event** - a change that activates a trigger. This can be:

- A DML event such as `UPDATE`, `INSERT` or `DELETE`
- A DDL event such as `CREATE`
- A database event such as `SERVERERROR ON DATABASE`

For DML events, there are **row-level** and **statement-level triggers**; the former occurs for each modified row while the latter runs once for each statement.

Once an appropriate event occurs, it must pass a **condition**; a query which determines if the trigger should be activated.

If the condition is met, the **action** will occur. This can be one or more statements (procedures).

The action can occur `BEFORE`, `AFTER`, or `INSTEAD OF`

```sql
CREATE|REPLACE TRIGGER [schema.]trigger_name
BEFORE|INSTEAD OF|AFTER
DELETE|INSERT|UPDATE OF attr_name_1, attr_name_2... OR DELETE|INSERT|UPDATE OF ...
ON [schema.]table_name|view_name
[REFERENCING OLD AS old_row_alias NEW AS new_row_alias]
FOR EACH ROW|STATEMENT
WHEN (condition)
  body
/
```
Within the SQL statements, you must use `:new` and `:old` to reference the new or old row values. TODO Only if `REFERENCING...` not set?

The `/` is used to end the trigger action. It must be on a new line.

Limitations:

- The name of the trigger must be unique
- The body cannot contain DDL or transaction statements
- The trigger cannot read from or modify the mutating table, with some exceptions
- `INSTEAD OF` is only available for views
- `WHEN` is only available for row-level triggers. The condition cannot be a query

To alter the trigger:

```sql
ALTER TRIGGER [schema.]trigger_name ENABLE|DISABLE|COMPILE [DEBUG]
```

`SHOW ERRORS [schema.]trigger_name` shows any errors.

###### Example: Audit Trigger

This uses example uses PL/SQL

```sql
CREATE [OR REPLACE] TRIGGER audit_trigger BEFORE INSERT OR DELETE OR UPDATE ON table_name
FOR EACH ROW
begin
  if INSERTING then
    INSERT INTO audit_table VALUES (USER || 'inserting' || 'new id:' || :new.id);
  elsif DELETING then
    INSERT INTO audit_table VALUES (USER || 'deleting' || 'old id:' || :old.id);
  elsif UPDATING('attribute_name') then
    INSERT INTO audit_table VALUES 
      (USER || 'updating' || 'old value:' || :new.attribute_name || 'new value:' || :new.attribute_name);
  elsif UPDATING then
    INSERT INTO audit_table VALUES 
      (USER || 'updating' || 'old id:' || :old.id || 'new id:' || :new.id);
  end if;
end;
/
```

PLSQL:

```sql
DECLARE
  varname type := initial_value;
  varname2 type;
BEGIN
  SELECT attribute INTO varname FROM table_name WHERE ...;
  RAISE_APPLICATION_ERROR(num => error_code, msg => 'Message');
  -- Error code between -20999 and -20000
  ...;
EXCEPTION
  handlers;
END;
```

Cannot use `EXISTS`: must store `COUNT(*)` into variable.

##### Procedures

Collection of statements; basically functions

```sql
CREATE|REPLACE PROCEDURE [schema].procedure_name
argument_name [IN|IN OUT|OUT] datatype, ...
IS|AS
  body
```

The body cannot contain DDL statements.

Compiling a procedure: `ALTER PROCEDURE [schema.]procedure_name COMPILE`

### Database Security

**Discretionary** and **mandatory** security mechanisms

Control measures:

- Access control: user accounts
- Inference control: operations a user can make

The **DBA** is responsible for the overall security of the database. They have the responsibility to grant privileges to users and assign security levels users and data.

They can set privileges at the **account** and **relation** level:

- Account: specifies operations that the account is allowed to run
- Relation: specifies operations the account is allowed to run on individual tables

Each table is assigned an **owner account**; they have **all** privileges for the table, and can give privileges to other users.

Privileges can also be specified using views, allowing, for example, users access to only some attributes of a table.

```sql
GRANT account_privilege|table_privilege|ALL PRIVILEGES
ON object
TO user|role|PUBLIC
WITH GRANT OPTION;


REVOKE account_privilege|table_privilege|ALL PRIVILEGES
ON object
FROM user|role|PUBLIC;

/* EXAMPLES */
GRANT CREATE TABLE TO user WITH GRANT OPTION;
GRANT INSERT, DELETE ON table1, table2 TO user;
GRANT UPDATE ON table1(attribute1) TO user;
```

Table privileges: `SELECT; INSERT; UPDATE; ALTER; DELETE; INDEX; DEBUG; REFERENCES`. `INSERT`, `UPDATE` and `REFERENCES` (allows user to have a FK to the table) can be constraint to specific attributes.

If `GRANT OPTION` is set, the user granted the privilege can grant the privileges to other users; **propagation**. However, if the privilege is revoked, **all propagated privileges are automatically revoked**.


