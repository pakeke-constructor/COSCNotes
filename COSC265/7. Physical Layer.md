# 7: Physical Layer

## Internal Schema

Good database design usually requires multiple tables and hence, many select operations will require access to multiple tables, which lead to performance complexities.

DBMS designers must ensure the database, which will be stored in persistent memory, performs well. They must take into factors such as:

- Secondary storage
- Buffering, caching
- Indexing strategy
- Query optimization
- Networks
- Concurrency

The database designers can affect performance through:

- Data types (e.g. using `int` instead of `varchar`)
- Degree of normalization
- Query formulation
- Overhead for constraints, triggers etc.
- Indexing strategies
- Media (never store media in a DB)

## Memory Hierarchy

Primary memory - cache and main memory:

- Fast access
- Limited capacity
- Volatile

Secondary/tertiary memory - flash, HDDs, optical disks, tape:

- High capacity
- Low cost
- Non-volatile

### Disk Storage Devices

- Data stored as magnetized areas
- A **disk pack** contains several magnetic disks connected to a rotating spindle
- Each surface of the disk is divided into concentric circular **tracks**, each storing 4-50 kB
- Tracks are divided into **blocks**/**sectors** - arcs of the sector
  - They are typically 512 B to 4 kB in size
  - The **entire block** is read/written to at once
- A **read-write head** moves to the track containing the block to be transferred
  - Reading/writing is time consuming due to seek times, *s*, and rotational delay, *rd*
- A physical disk block address consists of:
  - A cylinder number: the disk containing the data
  - The track number
  - The block number

## Record Management

- A **file** is a sequence of records
- Each **record** is a collection of fields; a row
- Each **field** contains values for a certain data type
- A file can have **fixed- or variable-length** records, and records can have fixed- or variable-length fields
  - If variable-length, separator characters or length fields are required

Multiple records are stored in a **block**:

- The **blocking factor**, *bfr* is the number of records per block
- File records can be:
  - **unspanned**: records are always in a single block. This is preferred as it means only a single read is required to get a particular record
  - **spanned**: records can be stored in multiple blocks
- If unspanned and the blocking factor is not an integer, there will be empty space on a block
- If a file contains fixed-length records, unspanned blocking is usually used

## File Organization

The DBMS:

- Uses the OS/file system APIs to read/write physical blocks (pages) between disks and memory
- May store DB data on multiple disks; if the block size is different and the records are unspanned, this may cause headaches
- May have its own file system
  - An in-memory database relies on the main memory for data storage, leading to faster access but also the potential for data loss if the system crashes

The **file descriptor/header** contains metadata for the file, such as field names, data types and addresses of the file blocks on the disks. The physical disk blocks can be *contiguous*, *linked* or *indexed*.

Typical file operations:

- Open: ready the file
- Find: search for the first record satisfying a condition, and makes it the current record
- Find next: searches for the next record satisfying a condition, and makes it a current record
- Read: read the current record into a variable
- Insert: insert a new record into the file, and make it the current record
- Delete: remove the current file record (usually by marking it as invalid)
- Modify: change the value of fields in the current record
- Close: terminate access to a file
- Reorganize: e.g. remove records marked as invalid
- Read ordered: read file blocks ordered by a certain field in the file

Unordered files:

- Called a **heap**/**pile** file
- Efficient insertion: new records inserted at the end
- Linear search required to search for a record
- Reading ordered by a particular field requires sorting

Ordered files:

- Records sorted by an **ordering field**
- Update is expensive; must be inserted in the correct order
  - A overflow/transaction file, which is periodically merged with the main ordered file, may be used to improve performance
  - If it is near the start, all records after that may need to be moved
- Binary search can be used to search for the record on its ordering field value
- Reading the records in the order of the ordering field is efficient

### Hashed Files (External Hashing)

- File blocks divided into *M* equal-size **buckets** (usually corresponding to one or a fixed number of disk blocks)
- The record with hash key *K* is stored in bucket *i* where `i=h(K)`, `h` is the **hashing function** (e.g. modulo)
- Search via the hash key is efficient
- When a bucket is full, a **overflow bucket** is used; bucket has pointer to overflow bucket

Collision Resolution:

- Open addressing: put in the next available position
- Chaining: place in overflow bucket
- Multiple-hashing: if collision occurs, use a secondary hash function etc. Fall back to open addressing

Misc. notes:

- For performance, the hash file is kept 70-80% complete
- The hash function should distribute the records uniformly; otherwise, overflow records will increase search time
- **Ordered access on the hash key is inefficient**; requires sorting
- Fixed number of buckets; problem if the number of records grows or shrinks

TODO is overflow bucket for a specific bucket or for any bucket

## Redundant Arrays of Independent DiskS (RAID)

Uses parallelism across multiple disks to increase reads/write performance using **data striping**.

RAID levels:

- Level 0: striping, but no redundant data; best write performance
- Level 1: mirrored disks; show as writes have to be performed on both disks
- Level 4: block-level data striping, with parity information stored on one or more disks
- Level 5: level 4, but parity information distributed across all disks
- Level 6: *P + Q* redundancy with Reed-Solomon codes. Two disks can fail with no data loss
- Level 10 (1 + 0): RAID 0, but each 'disk' is a set of RAID 1 mirrored disks

## Indexing

The physical order of records affects the efficiency of individual queries requiring file travesal. However, physical records can only be ordered by a single ordering field, the **primary index**.

Indexes provide an efficient way to access records in different orders without expensive operations like sorting or duplicate data by creating a data structure that maps between a key and address.

Clustering index: an index consisting of candidate keys .


## Physical Level in Oracle
