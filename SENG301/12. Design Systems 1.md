# 12. Design Systems 1

<!--Pick codebase, preferably Java, which you understand

Software: art or science?
-->

How do we quantify 'good'? How precise can we be? Common language required to describe this.

## Big-picture language

Cohesion:

- Things are in the right place
- Data and behaviour together
- Keep connections local

Coupling:

- Independence between modules
- Separation of concerns/information hiding
- Simple interfaces

**Cohesion good; coupling bad**.

## Why is software design hard?

Problem: complexity

Solution: decomposition

- Too big? break it up
- Too many parts? Hide them
- Too many connections? Decouple it
- Changing too much? Abstract it

## Methodologies

Top-down:

- Functional decomposition
- Stepwise refinement
- Transaction analysis

Bottom-up:

- Combination of lower-level components: figure out what you need, then combine them

**Nucleus-centered** (OO):

- Information hiding
- Decide what the critical core (algorithms etc.) is, then build interfaces around it

Aspect-oriented (e.g. security):

- Separation of concerns

### Nucleus-Centered Design

Hide information; decisions, choices, things that may change in the future (David Parnas).

Identify decision decisions with **competing solutions**; isolate these details behind an interface i.e. OO-design; state/access methods encapsulated.

#### Example: Student

```

Student             StudentDialog
name      <-------- student
id
display()?          display()?
```

Where should `display()` go?

If in `StudentDialog`, allows for **separation of concerns**.

If in `Student`, keeps **related data and behaviour together**, increasing cohesion.

#### Information-Hiding

Encapsulation: drawing a boundary around something.

Information hiding: hiding design decisions from the rest of the system **to prevent unintended coupling**.

Encapsulation = programming feature; information hiding = design pattern.

##### Encapsulation Leak

```java
// Student
private Set<Enrolment> enrolments;
public Set<Enrolment> getEnrolments() {
  // Bad
  return enrolments;

  // Better: items cannot be added/removed, but setters/getters can still be called on elements
  // Deep clone?
  return Collections.unmodifiableSet(enrolments);
}

// Course
add(Student student) {
  // Bad: set is being modified outside of the Student class
  student.getEnrolements().add(new Enrolment(student));
}
```

##### Coping with Change

Figure out the solid bits; the invariants, and make them the framework of your program. Hopefully, the problem won't change.

Find the wobbly bits and hide them away.

##### Hiding Design Decisions

If you *chose* something (i.e. multiple options available), hide it:

- Data representations
- Algorithms
- IO format
- Mechanisms (inter-process communication, persistence)
- Lower-level interfaces
