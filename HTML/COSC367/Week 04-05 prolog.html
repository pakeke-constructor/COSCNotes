<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>Week 04-05 prolog</title></head>
<body><h1>Weeks 04-05: Prolog</h1>
<h2>Prolog - <em>pro</em>gramming in <em>log</em>ic</h2>
<h3>Intro</h3>
<ul>
<li><p>Describe the situation of interest</p>
</li>
<li><p>Ask a question</p>
</li>
<li><p>Prolog logically deduces new facts, and gives deductions back as answers</p>
</li>
<li><p>Prolog has an interactive interpreter</p>
<ul>
<li>To exit, use <code>halt.</code></li>
<li>Load a knowledge base using <code>consult(filename).</code></li>
<li>Reload using <code>reconsult(filename).</code></li>
<li><code>make.</code> reloads all changed source files</li>
<li>Ask queries in interactive mode (<code>?:</code>)</li>
<li>Comments: <code>/**/</code> and <code>%</code></li>
<li><code>write(+Term)</code> always succeeds. It prints out stuff.</li>
<li><code>trace/1</code></li>

</ul>
</li>

</ul>
<h3>Basic Syntax</h3>
<ul>
<li><p>Facts and rules are both clauses</p>
<ul>
<li>The end of a clause is marked with a full stop</li>

</ul>
</li>
<li><p><code>happy(yolanda).</code> is a fact</p>
<ul>
<li><code>happy</code> is a <strong>predicate</strong>; a <strong>test</strong> - it is &#39;true&#39; (provably true) or &#39;false&#39; (unknown) for the given argument; it is not a function call</li>

</ul>
</li>
<li><p><code>listensToMusic(yolanda) :- happy(yolanda).</code> is a rule</p>
<ul>
<li>If RHS (head) is true, then LHS (body) must be true</li>
<li><code>:-</code> means <span class="MathJax_SVG" tabindex="-1" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.968ex" height="1.644ex" viewBox="0 -605.1 1277.8 707.6" role="img" focusable="false" style="vertical-align: -0.238ex;"><defs><path stroke-width="0" id="E2-MJMAIN-2190" d="M944 261T944 250T929 230H165Q167 228 182 216T211 189T244 152T277 96T303 25Q308 7 308 0Q308 -11 288 -11Q281 -11 278 -11T272 -7T267 2T263 21Q245 94 195 151T73 236Q58 242 55 247Q55 254 59 257T73 264Q121 283 158 314T215 375T247 434T264 480L267 497Q269 503 270 505T275 509T288 511Q308 511 308 500Q308 493 303 475Q293 438 278 406T246 352T215 315T185 287T165 270H929Q944 261 944 250Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#E2-MJMAIN-2190" x="0" y="0"></use></g></svg></span><script type="math/tex">\leftarrow \textrm{}</script></li>

</ul>
</li>
<li><p><code>,</code> means conjunction (<span class="MathJax_SVG" tabindex="-1" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.549ex" height="1.76ex" viewBox="0 -655.4 667 757.9" role="img" focusable="false" style="vertical-align: -0.238ex;"><defs><path stroke-width="0" id="E3-MJMAIN-2227" d="M318 591Q325 598 333 598Q344 598 348 591Q349 590 414 445T545 151T611 -4Q609 -22 591 -22Q588 -22 586 -21T581 -20T577 -17T575 -13T572 -9T570 -4L333 528L96 -4Q87 -20 80 -21Q78 -22 75 -22Q57 -22 55 -4Q55 2 120 150T251 444T318 591Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#E3-MJMAIN-2227" x="0" y="0"></use></g></svg></span><script type="math/tex">\land</script>)</p>
</li>
<li><p><code>;</code> means disjunction (<span class="MathJax_SVG" tabindex="-1" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.549ex" height="1.76ex" viewBox="0 -655.4 667 757.9" role="img" focusable="false" style="vertical-align: -0.238ex;"><defs><path stroke-width="0" id="E4-MJMAIN-2228" d="M55 580Q56 587 61 592T75 598Q86 598 96 580L333 48L570 580Q579 596 586 597Q588 598 591 598Q609 598 611 580Q611 574 546 426T415 132T348 -15Q343 -22 333 -22T318 -15Q317 -14 252 131T121 425T55 580Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#E4-MJMAIN-2228" x="0" y="0"></use></g></svg></span><script type="math/tex">\lor</script>). It can defined by having two rules; this is just syntactic sugar</p>
</li>

</ul>
<h3>Variables</h3>
<p>Variables start with an underscore or upper case letter, and may contain upper, lower, digits or underscores. <code>happy(X).</code> returns a term that replaces <code>X</code> such that the rule is met. Typing <code>j</code> tries to find another term that satisfies the rule.</p>
<p>Conjunction can also be used e.g. <code>happy(X), listensToMusic(X).</code>.</p>
<p>Variables can be in the knowledge base as well e.g. <code>jealous(X,Y) :- loves(X,Z), loves(Y,Z).</code></p>
<h3>Atoms</h3>
<p>A sequence of characters (upper, lower, digits, underscore) starting with a lowercase letter OR a sequence of special characters (<code>:</code>, <code>,</code>, <code>;</code>, <code>.</code>, <code>:-</code>). Atoms can be enclose in single quotes if it does not meet the naming requirements (e.g. <code>&#39;Yolanda&#39;</code>).</p>
<h3>Complex terms</h3>
<p>Functor directly followed by a sequence of arguments - put in brackets, separated by commas. e.g. <code>listensToMusic(yolanda)</code>, <code>hide(X,father(father(father(butch))).</code>.</p>
<h3>Arity</h3>
<p>The number of arguments a complex term has; predicates with the same functor but different arity can be defined.</p>
<h3>Unification</h3>
<p>Two terms unify if they are the same term or contain variables that can be uniformly instantiated with terms in a way such that the resulting terms are equal.</p>
<p>e.g. <code>woman(mia) = woman(mia).</code> <code>woman(Z)</code> and <code>woman(mia)</code> will be unified, with <code>Z</code> taking the value of <code>mia</code>.</p>
<p>e.g. defining <code>horizontal(line(point(X,Y), point(X,Z))).</code> and running <code>horizontal(line(point(1,2), point(X,3))).</code> will unify to <code>X=1</code>.</p>
<h3>Search Tree</h3>
<pre><code class='language-prolog' lang='prolog'>f(a).
f(b).
g(a).
g(b).
h(b).
k(X):-f(X),g(X),h(X).
</code></pre>
<p>Asking <code>?: k(Y).</code> will:</p>
<ul>
<li>Set <code>Y=X</code></li>
<li>Replace <code>k(Y).</code> with `f(X), g(X), h(X)</li>
<li>Try <code>X=a</code></li>
<li><code>f(a)</code> succeeds</li>
<li><code>g(a), h(a).</code>: dead end</li>
<li>Try <code>X=b</code></li>
<li><code>`f(b),g(b),h(b)</code> becomes <code>g(b), h(b)</code> becomes <code>h(b)</code> becomes empty; success</li>
<li>Get <code>Y=B</code></li>

</ul>
<h4>Recursion</h4>
<p>For recursive predicates using conjunction, place the non-recursive term first - using DFS, so will run out of memory otherwise.</p>
<pre><code class='language-prolog' lang='prolog'>numeral(0).
numeral(succ(X)):-numeral(X).
</code></pre>
<p>Where <code>succ(X)</code> returns <code>X + 1</code>: 3 could be defined as <code>numeral(succ(succ(succ(0)))).</code> <code>numeral(X).</code> will continue going on forever. Beware of running out of memory e.g. <code>p:-p.</code>.</p>
<h3>Addition</h3>
<p><code>add(0,X,X).</code> is the base clause. No return values, so three arguments needed (the last is the return value).</p>
<p><code>add(succ(X),Y,succ(Z)):-add(X,Y,Z).</code> is for the recursive case.</p>
<h3><code>Dif</code> predicate</h3>
<pre><code class='language-prolog' lang='prolog'>mother(X, Y) :- parent(X, Y), female(X).
sister(X, Y) :- parent(Z, X), parent(Z, Y), female(X).
</code></pre>
<p>Any female is their own sister so the <code>dif</code> predicate is required: append <code>X \= Y</code> to the end of the sister body.</p>
<h3>Predicate description - argument mode indicator</h3>
<p>Character prepended to argument when describing a functor:</p>
<ul>
<li>A <code>+</code> argument must be fully instantiated: must be input</li>
<li>A <code>-</code> argument must be unbound: must be an variable</li>
<li>A <code>?</code> argument can be either instantiated or unbound</li>

</ul>
<h3>Logical quantification</h3>
<p>Variables that appear in the head of a rule are universally quantified.</p>
<p>Variables that appear only in the body are existentially quantified.</p>
<p><code>path(X,Y) :- edge(X,Z), path(Z,Y).</code>: For <strong>all</strong> nodes <code>X</code> and <code>Y</code>, there exists a node <code>Z</code> such that there is an edge from <code>X</code> to <code>X</code> and a path from <code>X</code> to <code>Y</code></p>
<h2>Lists</h2>
<p>A finite sequence of elements e.g. <code>[[], dead(z), [2, [b, c]], Z, 3]</code>.</p>
<p>Lists as implemented as linked lists. A non-empty list has two parts:</p>
<ul>
<li><p>The head: the first item in the list (type element)</p>
</li>
<li><p>The tail: everything else (type list)</p>
<ul>
<li>The last element will be a special empty list <code>[]</code> - it has neither a head or tail</li>

</ul>
</li>

</ul>
<p>The <code>|</code> operator decomposes a list into a head and tail:</p>
<ul>
<li><code>[Head|Tail] = [a, b, c, d]</code> (or vice-versa) sets <code>Head</code> to <code>a</code> and <code>Tail</code> to <code>[b, c, d]</code></li>
<li><code>[X,Y,Z] = [a, b, c, d]</code> also works, setting <code>Z</code> to <code>[c, d]</code></li>
<li><code>[X|Y] = []</code> fails as the empty list has neither a head or tail.</li>

</ul>
<h3>Anonymous variables</h3>
<p>If you do not need the value of a variable, use <code>_</code> - the anonymous variable. Two instances of <code>_</code> may not be equal.</p>
<h3>Membership</h3>
<p>Is an element a member of a list? Use <code>member/2</code>:</p>
<pre><code class='language-prolog' lang='prolog'>member(X, [X|_]). % If element is the head, it is in the list
member(X, [_|T]) :- member(X, T). % Else, recurse through the list until it fails
</code></pre>
<p><code>member(X, [a, b, c])</code> can unify to three separate values.</p>
<pre><code class='language-prolog' lang='prolog'>% Exercise: a2b/2; first length all a&#39;s and second list all b&#39;s; both of the same length

a2b([], []).
a2b([a, L1], [b, L2]) :- a2b(L1, L2).
</code></pre>
<h3>Append</h3>
<p>Append two lists together using <code>append/3</code>, where the third argument is the result of concatenating the lists together.</p>
<pre><code class='language-prolog' lang='prolog'>append([], L, L).
append([H|L1], L2, [H|L3]) :- append(L1, L2, L3).
% If L3 is result, first elements of L1 and L3 must be the same. Hence, remove the first element from both L1 and L3 until L1 is empty.
</code></pre>
<p>Concatenating a list is done by traversing down one of the lists; hence, it is inefficient.</p>
<h4>Prefix and Suffix</h4>
<p><code>prefix(P, L) :- append(P, _, L).</code> with <code>prefix(X, [a, b, c])</code> generating all possible prefix lists of <code>[a, b, c]</code>.</p>
<p><code>suffix(S, L) :- append(_, S, L)</code>. with <code>suffix(X, [a, b, c])</code> generating all possible suffix lists of <code>[a, b, c]</code>.</p>
<h3>Sublist</h3>
<p>Sublists are prefixes of suffixes of the list:</p>
<pre><code class='language-prolog' lang='prolog'>sublist(Sub, List) :- suffix(Suffix, List), prefix(Sub, Suffix).
</code></pre>
<h3>Reversing a list</h3>
<p>If given <code>[H|T]</code>, reverse the list by reversing <code>T</code> and appending the list to <code>H</code>.</p>
<pre><code class='language-prolog' lang='prolog'>naiveReverse([], []):
naiveReverse([H|T], R) :- naiveReverse(T, RT), append(RT, [H], R).
</code></pre>
<p>This is inefficient: <code>append/3</code> is <code>O(n)</code> and this is done at each stage, so it is <code>O(n^2)</code>.</p>
<p>By using an <em>accumulator</em>, we can improve things:</p>
<ul>
<li>The accumulator is a list, initially empty</li>
<li>Head of the list is prepended to the head of the accumulator</li>
<li>Repeat until the list is empty</li>

</ul>
<pre><code class='language-prolog' lang='prolog'>% Third argument is an accumulator
accReverse([], L, L). % If list is empty, reversed array is the accumulator
accReverse([H|T], Acc, Rev) :- accReverse(T, [H|Acc], Rev).

reverse(L1, L2) :- accReversse(L1, [], L2).
% append/3 not used
</code></pre>
<pre><code>List          Acc
[a, b, c, d]  []
[b, c, d]     [a]
[c, d]        [b, a]
[d]           [c, b, a]
[]            [d, c, b, a]

</code></pre>
<h2>Arithmetic and other operators</h2>
<figure><table>
<thead>
<tr><th>C</th><th>Prolog</th></tr></thead>
<tbody><tr><td><code>&lt;</code></td><td><code>&lt;</code></td></tr><tr><td><code>&lt;=</code></td><td><code>=&lt;</code></td></tr><tr><td><code>==</code></td><td><code>=:=</code></td></tr><tr><td><code>!=</code></td><td><code>=/=</code></td></tr><tr><td><code>&gt;=</code></td><td><code>&gt;=</code></td></tr><tr><td><code>&gt;</code></td><td><code>&gt;</code></td></tr></tbody>
</table></figure>
<p>These force the left and right hand arguments to be evaluated.</p>
<p><code>=</code> is the unification predicate and <code>\=</code> is the negation. <code>==</code> is the identity predicate, which succeeds if the arguments are identical. </p>
<p><code>2+2 = 4.</code> is false as <code>+(2, 2)</code> does not unify to <code>4</code>. You must use <code>2+2 =:= 4</code>.</p>
<p><code>!</code> is the cutback operator - it supresses backtracking. The <code>fail</code> predicate always fails. Using these two allows us to invert the result:</p>
<pre><code class='language-prolog' lang='prolog'>neg(Goal) :- Goal, !, fail.
</code></pre>
<p>If <code>Goal</code> unifies, it gets to <code>!</code> so can never backtrack. Then it gets to <code>fail</code> an fails. If the <code>!</code> was not there, it would attempt to evaluate <code>Goal</code> again.</p>
<p>As this is so common, there is a built in operator that does this: <code>\+</code>.</p>
</body>
</html>