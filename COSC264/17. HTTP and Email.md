# 17. HTTP and Email

## HTTP

### HTTP Connections

**Non-persistent HTTP**: At most *one object* is sent over a TCP connection. Used by HTTP/1.0.

**Persistent HTTP**: multiple objects can be sent over a single TCP connection; used by HTTP/1.1 by default.

The client will initialize the TCP connection, send an HTTP *request message* (containing some URL); the server will receive this response and form a *response message* containing the requested object.

HTTP/1.0 will close the TCP connection after the object is delivered, while persistent HTTP will leave the connection open and use the same connection for subsequent HTTP requests.

**Response Time Modelling (RTT)**: time to send a small packet to travel from the client to the server and back.

For HTTP/1.0:

- 1 RTT to initiate the TCP connection (first two parts)
- 1 RTT for the HTTP request (and third part of handshake) and the request back

Hence, the total time is 2 RTTs, plus the transmission time for the file. After the file is received, the TCP connection must also be closed.

In addition to this, the OS must allocate resources for each TCP connection; browsers will often use parallel TCP connections to fetch referenced objects.

**Persistent HTTP with pipelining** is the default behaviour in HTTP/1.1; the client sends requests as soon as it encounters a referenced file.

### HTTP Messages

The HTTP request consists of the following ASCII-encoded text:

- Request line (the tree values are separated by a space):
  - Method (`GET`, `POST`, `PUT`, `HEAD` etc.)
  - URL
  - Version (`HTTP/1.0`, `HTTP/1.1` etc.)
  - `\r\n` to end the request line
- Header lines:
  - `header_field_name: header_value\r\n` (space required after the colon)
  - Order of headers not significant, but fields sending control data should be sent field
  - `\r\n` after all header lines to indicate the end of the header section
- Entity body
  - Used for `POST` and `PUT` requests

Some methods:

- `GET`: get object
- `HEAD`: get the headers that would be returned if it was a `GET` request
- `POST`: filling out a form
- `PUT` (1.1+): upload file in entity body to path specified in URL field
- `DELETE` (1.1+): delete file specified in URL field

Some headers:

- `User-agent`
- `Connection: close|keep-alive`: defaults to `keep-alive` for HTTP/1.1
- `Accept-language`: comma-separated list of languages and optional quality value for each language
  - Language code can be language or language and region (e.g. `en`, `en-gb`)
  - Weight: estimate of user's preference for that language. `lang-code;q=weight,`. Defaults to `q=1`, can be any fraction between `0` and `1` (larger is better)

The response message follows this format:

- Status line (space-separated):
  - Version
  - Status code (e.g. `200`, `400`)
  - Phrase (text description of status code (e.g. `OK`))
  - `\r\n`
- Header lines:
  - `header_field_name: header_value\r\n` (space required after the colon)
  - `\r\n` after all header lines to indicate the end of the header section
- Entity body

Some HTTP status codes:

- `1xx`: request received, continuing process
- `2xx`: request successful
  - `200`: OK
- `3xx`: redirection
  - `301`/`308`: permanent redirect. The latter enforces that the request method (e.g. `GET`, `POST`) cannot change
  - `302`/`307`: temporary redirect. The latter enforces that the request method (e.g. `GET`, `POST`) cannot change
  - `304`: not modified since `If-Modified-Since` value
- `4xx`: client error
  - `400`: bad request
  - `404`: not found
- `5xx`: server error
  - `500`: internal server error
  - `502`: bad gateway (proxy/gateway received invalid response from upstream server)
  - `503`: service unavailable (e.g. overloaded)
  - `505`: HTTP version not supported

### Cookies: User-Server State

HTTP is stateless, so to identify users *cookies* are used. There are four components:

- Cookie header line in HTTP response message
  - Multiple `Set-cookie` lines can be sent
  - The header format is `Set-cookie: cookie_name=cookie_value`
    - By default, cookies are *session cookies* which are deleted after the current session ends
    - `; Expires = DoW, dd mmm yyyy, hh:mm:ss ttt;` can be appended to make it a *permanent cookie*
    - `; Secure;` ensures it is only sent on HTTPS connections
    - `; HttpOnly` ensures it is not accessible through JS
- Cookie header line in HTTP request message
  - `cookie: cookie1_name=cookie1_value; cookie2_name=cookie2_value...`
- Cookie file kept on the client and managed by the browser
- Server's database storing cookies

### Web Caches (Proxy Servers)

Proxy servers sit between the origin server and client. There can be multiple proxy servers, one of which will hopefully be closer to the client than the origin server.

The proxy server/cache acts as both a client and server. It helps to:

- Reduce response time
- Reduce traffic on an institution's access link
- Lower bandwidth costs

If the requested object is in the cache, the browser will use it. Otherwise, it will make a request to the proxy server (and if the proxy does not have the resource, it will in turn make a request to the origin server).

#### Conditional GET

The server will not send the object if the cache has an up-to-date copy of the object.

Request header: `If-modified-since: some_date`

If the object has not been modified since the given date, a `304 Not Modified` response will be sent and there will be no body. Otherwise, it will generate a normal `200 OK` response.

## Email

Three major components:

- User agent
  - Agent through which the user accesses and sends email
- Mail server
  - Has a **mailbox** containing incoming messages
  - Has a **message queue** of outgoing messages to send
- SMTP
  - Protocol used to exchange information between mail servers
  - Mail servers **run both the client and server**

### SMTP (Simple Mail Transfer Protocol)

The standard protocol used to transfer email between servers.

Basic operation:

- A uses a user agent (UA) to compose message
- A's UA sends the message to their mail server and places it in a message queue
  - Called a **email submission**
- A's mail server's SMTP client opens a TCP connection with B's mail server's SMTP server
  - If multiple messages need to be sent, they are sent over a persistent TCP connection
- B's mail server places the message in B's client
- B uses his UA to read the message

SMTP uses telenet connection and runs on **port 25** by default

Sample telenet interaction:

- TCP connection established; server sends three digit reply code (probably `220`) and information about the server (host name, server name/version, date/time etc.)
- Client sends `HELO client_host_name` message; server responds (with `250` if valid)
- Client sends `MAIL FROM: <user@client_host_name>` message; server confirms validity
- Client sends `RCPT TO: <user@server_host_name>` message; server confirms validity
- Client sends `DATA` message; server responds with delimiter used to close the email
- Client sends body content, ending it with the specified delimiter
  - Body content **typically restricted to 7-bit ASCII**
- Server responds with status message
- Client sends `QUIT` message

Mail message format:

```
From: user@client_host_name
To: user@server_host_name
Subject: subject_text
[BLANK LINE]
message_body
```

The receiving server appends a `Received: ` header line to the top of the message as a record of the  mail servers the email passed through.

### MIME (Multipurpose Internet Mail Extension)

For non-ASCII data, MIME is used. It specifies the type of content (e.g. jpeg, mp3) and the method in which it is encoded. For example:

```
...
Subject: subject_text
MIME-Version: 1.0
Content-Transfer-Encoding: base64
Content-Type: image/jpeg
[BLANK LINE]
base64_encoded data
```

In base64 encoding, every three octets (24 bits) are divided into four bytes of 6 bits each - enough to fit into an ASCII character. The characters `A-Za-z0-9+/` is used, with `A` corresponding to `0` and `/` to 63. `=` is used as padding.

### SMTP and Mail Access Protocols

Access protocols are used for communication between the receiver's mail server and user agent. Two mail protocols are:

- POP3 (Post Office Protocol):
  - After authorization, the message is simply downloaded
- IMAP (Internet Mail Access Protocol):
  - More features
  - Allows messages stored on the server to be manipulated

Web-based email is another alternative; the user agent uses HTTP to communicate with its remote mailbox.

#### POP3

TCP telenet connection running on port 110.

During the **authorization phase**, the client sends two commands:

- `user username`
- `pass password`

After each command is sent, the server responds with either `+OK` or `-ERR`.

During the **transaction phase**, the client can send:

- `list`: list message numbers
- `retr mail_num`: retrieve message by that number
- `dele mail_num`: delete message with that number

#### IMAP

IMAP:

- Keeps all messages in the server
- Allows the user to organize messages in folders
- Keeps state across sessions
- ALlows the user to obtain components of messages instead of the entire message

## Domain Name System (DNS)

DNS is:

- a directory service
- a distributed database implemented in a hierarchy of DNS servers
- an application-layer protocol (UDP on port 53)

Some DNS services:

- Hostname to IP address translation
  - On Linux, this can be done using the command `gethostbyname`
- Host aliasing
  - Canonical (`CNAME` records) and alias names (e.g. `www.`)
- Mail server aliasing (`MX` records)
- **Load distribution**
  - Reply to DNS request can return a list of IP addresses. With DNS rotation, the list can rotate, and as clients typically pick the first address, the load can be distributed to multiple servers

DNS is not centralized:

- Acts as a single point of failure
- Traffic volume too large
- Latency: will be far away from most hosts
- Maintenance almost impossible

### Hierarchy

DNS is composted of three main levels of DNS servers:

- **Root DNS** servers
- **Top-level domain** (TLD) servers
  - `com`, `org` etc.
- **Authoritative DNS** servers
  - May be provided by organization or service provider
  - Non-authoritative DNS servers will cache responses from the latter, so may not be accurate

If a client wants the IP address for `www.google.com`, to a first approximation, it will:

- Query the root server for the `com` DNS server
- Query the `com` DNS server to get the `google.com` DNS server
- Query the `google.com` DNS server for the IP address for `www.google.com`

There are 13 root name servers worldwide (although each is a cluster of replicated servers)

**Local name servers** do not belong to the hierarchy, but are central to the DNS architecture. Each ISP has provides one and acts as the **default name server**.

### Query Types and Caching

If a client wants the IP address for `www.google.com` through an **iterated query**:

- The client sends a query to the local DNS server
- The local DNS server sends a query to the root DNS server for the IP address of the `com` DNS server
- The local DNS server sends a query to the `com` DNS server for the IP address of the authoritative DNS server for `google.com` host
- The local DNS server sends a query to the authoritative DNS server for the `google.com` host for the IP address of `www.google.com`
- The local DNS forwards the reply back to the client

A **recursive query** puts the burden of name resolution to the contacted name server:

- The client sends a query to the local DNS server
- The local DNS server sends a query to the root DNS server for the IP address of `www.google.com`
- The root DNS server sends a query to the `com` DNS server for the IP address of `www.google.com`
- The `com` DNS server sends a query to the authoritative DNS server for the `google.com` host for the IP address of `www.google.com`
- The response recursive through the stack back to the client

Both queries require 8 messages. Hence, caching is used:

- Once any name server learns a mapping, it caches it
- TTL ensures cache entries expire

Hence, root name servers are usually not consulted

### DNS records

Each **resource record** stores the `name`, `value`, `type`, `ttl` and `class` (although that is always `IN` (internet)).

Some `types` values:

- `A`: `name` is hostname; `value` is the IP address
  - IPv6 uses the `type` `AAAA` as the IPv6 addresses use four times as many bits
- `NS`: `name` is the domain, `value` is the hostname of the authoritative name server for the domain
- `CNAME`: `name` is the alias name  for the canonical name stored in `value`
- `MX`: `value` is the canonical name of the mail server associated with the **alias name**

### DNS Messages

Both query and rely messages use the same message format:

```
|       16 bits      |       16 bits       |
|   Identification   |       Flags         |
|   Num. questions   |   Num. answer RPs   |
| Num. authority RPs | Num. additional RPs |
|        Questions (variable num.)         |
|       Answers (variable num. RRs)        |
|      Authority (variable num. RRs)       |
|    Additional info (variable num. RRs)   |
```

The query and reply to the corresponding query have the same identification number.

The flags indicate;

- If the message is a query (`0`) or reply (`1`)
- If the query is recursive or not
  - If a reply, it will indicate if the server supports it

The additional fields:

- Questions (`(Name, Type)`)
  - Reply will repeat these
- Answers (`(Type, Value, TTL)`)
- Authority: records for authoritative servers
- Additional information (e.g. IP address of authoritative DNS server)

### Adding New Records

Example: registering a domain name at a **registar**:

- Need to provide registar with host names and IP addresses of primary/secondary authoritative DNS servers
- Registar inserts two RRs into the TLD server for each authoritative name server
  - `(host_name, authoritative_DNS_server_host_name, NS)`
  - `(authoritative_DNS_server_host_name, authoritative_DNS_server_IP_address, A)`
- Go to the authoritative name server and insert records pointing to your server there

